///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>
///<reference path="GridGraph.ts"/>


/** 
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter. 
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
        var errors : Error[] = [];
        var plans : PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result : PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch(err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan : string[];
    }

    export function stringify(result : PlannerResult) : string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

    /**
     * The core planner function. The code here is just a template;
     * you should rewrite this function entirely. In this template,
     * the code produces a dummy plan which is not connected to the
     * argument `interpretation`, but your version of the function
     * should be such that the resulting plan depends on
     * `interpretation`.
     *
     * 
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
        var plan : string[] = [];

        var graph = new PGraph();
        var startNode = new PNode(state.stacks, state.holding, state.arm);
        

        return plan;
    }

}

function goal(interpretation : Interpreter.DNFFormula, state: WorldState, n: PNode) : boolean {
    var goal : boolean = false;

    for (var i = 0; i < interpretation.length; i++) {
        var condSatisfied : boolean = false;

        for (var j = 0; j < interpretation[i].length; j++) {
            var condition = interpretation[i][j];
            var firstArg : string = condition.args[0];

            if (condition.relation === "holding") {
                if (state.holding === firstArg)
                    condSatisfied = true;
            } else {
                var secArg : string = condition.args[1];
                var firstCord : Coordinate = findIndex(firstArg, state);
                
                if (secArg !== "floor") {
                    var secCord : Coordinate = findIndex(secArg, state);
                    
                    if (condition.relation === "leftof") {
                        if (firstCord.x < secCord.x) condSatisfied = true;    
                    } else if (condition.relation === "rightof") {
                        if (firstCord.x > secCord.x) condSatisfied = true;
                    } else if (condition.relation === "above") {
                        if (firstCord.x === secCord.x && firstCord.y > secCord.y)
                            condSatisfied = true;
                    } else if (condition.relation === "under") {
                        if (firstCord.x === secCord.x && firstCord.y < secCord.y)
                            condSatisfied = true;
                    } else if (condition.relation === "beside") {
                        if (Math.abs(firstCord.x - secCord.x) == 1)
                           condSatisfied = true; 
                    } else if (condition.relation === "ontop") {
                        if (firstCord.x === secCord.x && (firstCord.y-secCord.y) == 1)
                           condSatisfied = true; 
                    }
                }
            }       
        }
        if (condSatisfied) goal = true;
    }
    return goal;
}

function findIndex(obj : string, state : WorldState) {
    var coordinate : Coordinate = undefined;

    for (var i = 0; i < state.stacks.length; i++){
        for (var j = 0; j < state.stacks[i].length; j++) {
            if (state.stacks[i][j] === obj) {
                coordinate = {x:i, y:j};
                break;    
            }
        }
    }
    
    return coordinate;
}

class PGraph implements Graph<PNode> {

    outgoingEdges(node: PNode) : Edge<PNode>[] {
        return undefined; 
    }

   compareNodes : collections.ICompareFunction<PNode> = function (a : PNode, b : PNode) {
    return undefined;
   } 

}

class PNode {
    stack: Stack[];
    holding: string;
    arm: number;

    constructor (public _stack : Stack[], public _holding : string, public _arm : number) {
        this.stack = _stack;
        this.holding = _holding;
        this.arm = _arm;
    }

}
